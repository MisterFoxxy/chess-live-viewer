<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Он‑лайн партии</title>

  <!-- css и js chessground -->
  <link  rel="stylesheet"
         href="https://cdn.jsdelivr.net/npm/chessground@9/dist/chessground.css" />
  <script src="https://cdn.jsdelivr.net/npm/chessground@9/dist/chessground.min.js"></script>

  <!-- chess.js для «перематывания» ходов -->
  <script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0-beta.1/dist/chess.min.js"></script>

  <style>
    body{margin:0;padding:0;font-family:sans-serif;background:#f3f3f3}
    #boards{display:flex;flex-wrap:wrap;justify-content:center;gap:24px;padding:24px}
    .block{width:340px;background:#fff;border-radius:8px;
           box-shadow:0 2px 8px rgba(0,0,0,.08);overflow:hidden}
    .block .names{padding:6px 8px;font-weight:600;text-align:center;border-bottom:1px solid #eee}
    .cg-wrap{width:100%;height:340px}
  </style>
</head>
<body>
  <div id="boards"></div>

<script>
/* ---------- настройки ---------- */
const PGN_URL     = 'https://pgn-bridge.zerarfernando.workers.dev/pgn';
const REFRESH_MS  = 5000;          // как часто опрашивать (мс)
/* --------------------------------*/

const container = document.getElementById('boards');
const boardPool = [];              // сюда кладём созданные доски

// где лежат картинки фигур
function pieceTheme (piece) {
  // piece приходит вроде "wK", "bq" и т.п.
  return `pieces/${piece}.png`;
}

/* создать ещё один визуальный блок */
function spawnBlock () {
  const wrap   = document.createElement('div'); wrap.className = 'block';
  const names  = document.createElement('div'); names.className = 'names';
  const board  = document.createElement('div'); board.className = 'cg-wrap';
  wrap.append(names, board); container.appendChild(wrap);

  const cg = Chessground(board, {
    viewOnly   : true,
    coordinates: false,
    sprite     : { url: '',     // путь игнорируется когда pieceTheme есть
                   margin: 2,
                   pieceTheme }
  });
  return {wrap, names, ground: cg};
}

/* отобразить все партии */
function render (games) {
  // досок должно хватить
  while (boardPool.length < games.length) boardPool.push(spawnBlock());

  games.forEach((g, idx) => {
    const {wrap, names, ground} = boardPool[idx];
    names.textContent = `${g.white} — ${g.black}`;

    const chess = new Chess();
    g.moves.forEach(m => chess.move(m));
    ground.set({fen: chess.fen()});
    wrap.style.display = '';                       // на всякий случай
  });

  // если стало партий меньше, «лишние» блоки прячем
  for (let i = games.length; i < boardPool.length; i++)
    boardPool[i].wrap.style.display = 'none';
}

/* простой парсер PGN -> {white, black, moves[]} */
function parsePGN (txt) {
  return txt.split(/\n\n(?=\[Event)/).filter(Boolean).map(block => {
    const tag = t => (block.match(new RegExp(`\\[${t} "([^"]+)"`))||[])[1]||'?');
    const moves = block
      .replace(/\[\w+ "[^"]*"\]\s*/g, '')      // теги
      .replace(/\{[^}]*\}/g, '')               // комменты
      .replace(/\d+\.(\.\.)?/g, '')            // номера ходов
      .trim().split(/\s+/)
      .filter(s => !/^(1-0|0-1|1\/2-1\/2|\*)$/.test(s));
    return {white: tag('White'), black: tag('Black'), moves};
  });
}

/* циклическое обновление */
async function fetchAndUpdate () {
  try {
    const resp = await fetch(PGN_URL + '?t=' + Date.now());
    const txt  = await resp.text();
    render(parsePGN(txt));
  } catch (e) {
    console.error('Ошибка при получении PGN:', e);
  } finally {
    setTimeout(fetchAndUpdate, REFRESH_MS);
  }
}

fetchAndUpdate();
</script>
</body>
</html>
